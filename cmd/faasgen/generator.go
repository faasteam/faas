package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"sort"
	"strconv"
	"text/template"
)

const generatedFileTemplate = `// Code generated by faasgen. DO NOT EDIT.

package main

import (
	"github.com/faasteam/faas"
	{{- range .Imports }}
	{{ . }}
	{{- end }}
)

func init() {
	{{- range .HTTPFunclets }}
	{{- if eq .HTTPAnnotation.FuncletType "onAuthFunclet" }}
	faas.HandleAuth("{{ .HTTPAnnotation.Entry }}",  {{ .Package }}{{ .Name }})
	{{- else if eq .HTTPAnnotation.FuncletType "onMessageFunclet" }}
	faas.HandleFunc("{{ .HTTPAnnotation.Entry }}", "{{ .HTTPAnnotation.Type }}", "{{ .HTTPAnnotation.Path }}", faas.MessageHandler({{ .Package }}{{ .Name }}))
	{{- else if eq .HTTPAnnotation.FuncletType "onGattFunclet" }}
	faas.HandleFunc("{{ .HTTPAnnotation.Entry }}", "{{ .HTTPAnnotation.Type }}", "{{ .HTTPAnnotation.Path }}", faas.GattHandler({{ .Package }}{{ .Name }}, "{{ .HTTPAnnotation.ResPath }}"))
	{{- else if eq .HTTPAnnotation.FuncletType "onStaticFunclet" }}
	faas.HandleFunc("{{ .HTTPAnnotation.Entry }}", "{{ .HTTPAnnotation.Type }}", "{{ .HTTPAnnotation.Path }}", faas.StaticHandler({{ .Package }}{{ .Name }}, "{{ .HTTPAnnotation.ResPath }}"))
	{{- else if and (eq .HTTPAnnotation.FuncletType "onHandleFunclet") (eq .HTTPAnnotation.ParamCnt 2) }}
	faas.HandleFunc("{{ .HTTPAnnotation.Entry }}", "{{ .HTTPAnnotation.Type }}", "{{ .HTTPAnnotation.Path }}", {{ .Package }}{{ .Name }})
	{{- else if and (eq .HTTPAnnotation.FuncletType "onHandleFunclet") (eq .HTTPAnnotation.ParamCnt 3) }}
	faas.HandleFunc("{{ .HTTPAnnotation.Entry }}", "{{ .HTTPAnnotation.Type }}", "{{ .HTTPAnnotation.Path }}", faas.WithContextHandler({{ .Package }}{{ .Name }}))
    {{- end }}
	{{- end }}

	{{- range .TimingFunclets }}
	faas.TimingFunc("{{ .TimingAnnotation.Type }}", "{{ .TimingAnnotation.Interval }}", {{ .Package }}{{ .Name }})
	{{- end }}
}

func main() {
	faas.Run()
}
`

type TemplateData struct {
	HTTPFunclets   []*Funclet
	TimingFunclets []*Funclet
	Imports        []string
}

func generateCode(funclets []*Funclet, outputPath string) error {
	data := TemplateData{}
	importMap := make(map[string]int)
	pathMap := make(map[string]string)
	prefixMap := make(map[string]string)
	packagecnt := 0

	for _, f := range funclets {
		if f.HTTPAnnotation != nil {
			key := f.HTTPAnnotation.Entry + f.HTTPAnnotation.Path
			if f.HTTPAnnotation.Type == "path" {
				if pathMap[key] == "" {
					pathMap[key] = f.ImportPath + "@" + f.Name
				} else {
					return errors.New("path pattern conflict: " + f.HTTPAnnotation.Path + "   " + pathMap[key] + "  <------>  " + f.ImportPath + "@" + f.Name + "")
				}
			} else if f.HTTPAnnotation.Type == "prefix" {
				if prefixMap[key] == "" {
					prefixMap[key] = f.ImportPath + "@" + f.Name
				} else {
					return errors.New("prefix pattern conflict: " + f.HTTPAnnotation.Path + "   " + prefixMap[key] + "  <------>  " + f.ImportPath + "@" + f.Name + "")
				}
			}
		}
	}

	for _, f := range funclets {
		if f.ImportPath != "" {
			index, ok := importMap[f.ImportPath]
			if !ok {
				data.Imports = append(data.Imports, "a"+strconv.Itoa(packagecnt)+" \""+f.ImportPath+"\"")
				importMap[f.ImportPath] = packagecnt
				index = packagecnt
				packagecnt++
			}
			f.Package = "a" + strconv.Itoa(index) + "."
		}
		if f.HTTPAnnotation != nil {
			key := f.HTTPAnnotation.Entry + f.HTTPAnnotation.Path
			if f.HTTPAnnotation.Type == "prefix" && pathMap[key] == "" {
				f2 := *f
				f2.HTTPAnnotation = new(HTTPAnnotation)
				*f2.HTTPAnnotation = *f.HTTPAnnotation
				f2.HTTPAnnotation.Type = "path"
				data.HTTPFunclets = append(data.HTTPFunclets, &f2)
			}
			data.HTTPFunclets = append(data.HTTPFunclets, f)
		} else if f.TimingAnnotation != nil {
			data.TimingFunclets = append(data.TimingFunclets, f)
		}
	}
	sort.Slice(data.HTTPFunclets, func(i, j int) bool {
		return data.HTTPFunclets[i].HTTPAnnotation.Path < data.HTTPFunclets[j].HTTPAnnotation.Path
	})
	tmpl, err := template.New("faasgen").Parse(generatedFileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}
	os.Remove(outputPath)
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outputFile.Close()

	err = tmpl.Execute(outputFile, data)
	if err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	log.Printf("Generated code to %s\n", outputPath)
	return nil
}
